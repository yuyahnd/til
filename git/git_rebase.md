# git-rebase - Reapply commits on top of another base tip

[Git - git-rebase Documentation](https://git-scm.com/docs/git-rebase)

## オプション

* --onto \<newbase>  
    新しいコミットを作成する開始点。 --onto オプションが指定されていない場合、開始点は <upstream> です。 既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。<br><br>特殊なケースとして、マージ ベースが 1 つしかない場合、A と B のマージ ベースのショートカットとして "A...B" を使用できます。 A と B のいずれかを省略できます。省略した場合、デフォルトで HEAD になります。
* --keep-base  
    \<upstream> と \<branch> のマージ ベースに新しいコミットを作成する開始点を設定します。 git rebase --keep-base \<upstream> \<branch> を実行することは、 git rebase --reapply-cherry-picks --no-fork-point --onto \<upstream>...\<branch> \<upstream> < を実行することと同等です<br><br>このオプションは、アップストリーム ブランチ上で機能を開発している場合に役立ちます。 機能の作業中は、上流のブランチが前進する可能性があり、上流の上でリベースを続けるのは最善の考えではなく、ベース コミットをそのままにしておくのが最善の方法ではない可能性があります。 基本コミットは変更されていないため、このオプションは --reapply-cherry-picks を意味し、コミットが失われないようにします。<br><br>このオプションと --fork-point の両方が \<upstream> と \<branch> の間のマージ ベースを見つけますが、このオプションは新しいコミットが作成される開始点としてマージ ベースを使用しますが、 --fork-point はマージを使用します。 base を使用して、リベースされるコミットのセットを決定します。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* \<upstream>  
    比較する上流ブランチ。 既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。 デフォルトは、現在のブランチ用に構成されたアップストリームです。
* \<branch>  
    ワーキングブランチ; デフォルトはHEADです。
* --apply  
    適用戦略を使用してリベースします (内部で git-am を呼び出します)。 マージ バックエンドが適用バックエンドが行うすべての処理を行うと、このオプションは将来ノーオペレーションになる可能性があります。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --empty={drop,keep,ask}  
    開始するために空ではなく、アップストリーム コミットのクリーン チェリー ピックではないが、リベース後に空になるコミットを処理する方法 (既にアップストリームの変更のサブセットが含まれているため)。 drop (デフォルト) では、空になったコミットは破棄されます。 keep を使用すると、そのようなコミットが保持されます。 ask (--interactive で暗示) を使用すると、空のコミットが適用されるとリベースが停止し、それを削除するか、ファイルをさらに編集するか、空の変更をコミットするかを選択できます。 --exec などのその他のオプションは、-i/--interactive が明示的に指定されていない限り、デフォルトのドロップを使用します。<br><br>空で始まるコミットは保持され ( --no-keep-empty が指定されていない限り)、クリーンなチェリーピックであるコミット ( git log --cherry-mark ... によって決定される) は検出され、ドロップされることに注意してください。 予備ステップ ( --reapply-cherry-picks または --keep-base が渡されない限り)。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --no-keep-empty
* --keep-empty
    リベースの前に空で始まるコミット (つまり、親から何も変更しないコミット) を結果に保持しないでください。 そのようなコミットを作成するには、 --allow-empty オーバーライド フラグを git commit に渡す必要があるため、デフォルトでは、空で始まるコミットを保持します。これは、ユーザーが非常に意図的にそのようなコミットを作成しているため、それを保持したいことを示します。<br><br>インタラクティブなリベースを起動し、不要なコミットに対応する行を削除するだけで、空で始まるコミットを取り除くことができるため、このフラグの使用はおそらくまれです。 このフラグは、外部ツールが多くの空のコミットを生成し、それらをすべて削除したい場合などに便利なショートカットとして存在します。<br><br>空で開始せず、リベース後に空になるコミットについては、 --empty フラグを参照してください。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --reapply-cherry-picks
* --no-reapply-cherry-picks  
    プリエンプティブにドロップするのではなく、アップストリーム コミットのすべてのクリーン チェリー ピックを再適用します。 (これらのコミットがリベース後に空になった場合、すでにアップストリームの変更のサブセットが含まれているため、それらに対する動作は --empty フラグによって制御されます。)<br><br>--keep-base がない場合 (または --no-reapply-cherry-picks が指定されている場合)、これらのコミットは自動的に削除されます。 これにはすべてのアップストリーム コミットを読み取る必要があるため、読み取る必要があるアップストリーム コミットが多数あるリポジトリではコストがかかる可能性があります。 マージ バックエンドを使用する場合、ドロップされたコミットごとに警告が発行されます (--quiet が指定されていない場合)。 advice.skipedCherryPicks が false に設定されていない限り、アドバイスも発行されます (git-config を参照)。<br><br>--reapply-cherry-picks を使用すると、rebase はすべてのアップストリーム コミットの読み取りを省略できるため、パフォーマンスが向上する可能性があります。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
