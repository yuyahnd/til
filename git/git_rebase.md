# git-rebase - Reapply commits on top of another base tip

[Git - git-rebase Documentation](https://git-scm.com/docs/git-rebase)

## オプション

* --onto \<newbase>  
    新しいコミットを作成する開始点。 --onto オプションが指定されていない場合、開始点は <upstream> です。 既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。<br><br>特殊なケースとして、マージ ベースが 1 つしかない場合、A と B のマージ ベースのショートカットとして "A...B" を使用できます。 A と B のいずれかを省略できます。省略した場合、デフォルトで HEAD になります。
* --keep-base  
    \<upstream> と \<branch> のマージ ベースに新しいコミットを作成する開始点を設定します。 git rebase --keep-base \<upstream> \<branch> を実行することは、 git rebase --reapply-cherry-picks --no-fork-point --onto \<upstream>...\<branch> \<upstream> < を実行することと同等です<br><br>このオプションは、アップストリーム ブランチ上で機能を開発している場合に役立ちます。 機能の作業中は、上流のブランチが前進する可能性があり、上流の上でリベースを続けるのは最善の考えではなく、ベース コミットをそのままにしておくのが最善の方法ではない可能性があります。 基本コミットは変更されていないため、このオプションは --reapply-cherry-picks を意味し、コミットが失われないようにします。<br><br>このオプションと --fork-point の両方が \<upstream> と \<branch> の間のマージ ベースを見つけますが、このオプションは新しいコミットが作成される開始点としてマージ ベースを使用しますが、 --fork-point はマージを使用します。 base を使用して、リベースされるコミットのセットを決定します。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* \<upstream>  
    比較する上流ブランチ。 既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。 デフォルトは、現在のブランチ用に構成されたアップストリームです。
* \<branch>  
    ワーキングブランチ; デフォルトはHEADです。
* --apply  
    適用戦略を使用してリベースします (内部で git-am を呼び出します)。 マージ バックエンドが適用バックエンドが行うすべての処理を行うと、このオプションは将来ノーオペレーションになる可能性があります。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --empty={drop,keep,ask}  
    開始するために空ではなく、アップストリーム コミットのクリーン チェリー ピックではないが、リベース後に空になるコミットを処理する方法 (既にアップストリームの変更のサブセットが含まれているため)。 drop (デフォルト) では、空になったコミットは破棄されます。 keep を使用すると、そのようなコミットが保持されます。 ask (--interactive で暗示) を使用すると、空のコミットが適用されるとリベースが停止し、それを削除するか、ファイルをさらに編集するか、空の変更をコミットするかを選択できます。 --exec などのその他のオプションは、-i/--interactive が明示的に指定されていない限り、デフォルトのドロップを使用します。<br><br>空で始まるコミットは保持され ( --no-keep-empty が指定されていない限り)、クリーンなチェリーピックであるコミット ( git log --cherry-mark ... によって決定される) は検出され、ドロップされることに注意してください。 予備ステップ ( --reapply-cherry-picks または --keep-base が渡されない限り)。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --no-keep-empty
* --keep-empty
    リベースの前に空で始まるコミット (つまり、親から何も変更しないコミット) を結果に保持しないでください。 そのようなコミットを作成するには、 --allow-empty オーバーライド フラグを git commit に渡す必要があるため、デフォルトでは、空で始まるコミットを保持します。これは、ユーザーが非常に意図的にそのようなコミットを作成しているため、それを保持したいことを示します。<br><br>インタラクティブなリベースを起動し、不要なコミットに対応する行を削除するだけで、空で始まるコミットを取り除くことができるため、このフラグの使用はおそらくまれです。 このフラグは、外部ツールが多くの空のコミットを生成し、それらをすべて削除したい場合などに便利なショートカットとして存在します。<br><br>空で開始せず、リベース後に空になるコミットについては、 --empty フラグを参照してください。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --reapply-cherry-picks
* --no-reapply-cherry-picks  
    プリエンプティブにドロップするのではなく、アップストリーム コミットのすべてのクリーン チェリー ピックを再適用します。 (これらのコミットがリベース後に空になった場合、すでにアップストリームの変更のサブセットが含まれているため、それらに対する動作は --empty フラグによって制御されます。)<br><br>--keep-base がない場合 (または --no-reapply-cherry-picks が指定されている場合)、これらのコミットは自動的に削除されます。 これにはすべてのアップストリーム コミットを読み取る必要があるため、読み取る必要があるアップストリーム コミットが多数あるリポジトリではコストがかかる可能性があります。 マージ バックエンドを使用する場合、ドロップされたコミットごとに警告が発行されます (--quiet が指定されていない場合)。 advice.skipedCherryPicks が false に設定されていない限り、アドバイスも発行されます (git-config を参照)。<br><br>--reapply-cherry-picks を使用すると、rebase はすべてのアップストリーム コミットの読み取りを省略できるため、パフォーマンスが向上する可能性があります。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --allow-empty-message  
    ノーオペレーション。 以前は、空のメッセージを含むコミットのリベースは失敗し、このオプションはその動作をオーバーライドし、空のメッセージを含むコミットをリベースできるようにしていました。 空のメッセージでコミットしてもリベースが停止しないようになりました。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* -m
* --merge  
    マージ戦略を使用してリベースします (デフォルト)。<br><br>リベース マージは、\<upstream> ブランチの最上位の作業ブランチから各コミットを再生することによって機能することに注意してください。 このため、マージの競合が発生した場合、私たちとして報告された側は、これまでにリベースされたシリーズであり、\<upstream> で始まり、彼らの側が作業ブランチです。 つまり、側面が交換されます。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* -s \<strategy>
* --strategy=\<strategy>  
    デフォルトの ort の代わりに、指定されたマージ戦略を使用します。 これは --merge を意味します。<br><br>git rebase は、指定された戦略を使用して \<upstream> ブランチの最上位の作業ブランチから各コミットを再生するため、ours 戦略を使用すると、\<branch> からすべてのパッチが単純に空になりますが、これはほとんど意味がありません。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* -X \<strategy-option>
* --strategy-option=\<strategy-option>  
    \<strategy-option> をマージ戦略に渡します。 これは --merge を意味し、戦略が指定されていない場合は -s ort を意味します。 上記の -m オプションのように、私たちのものと彼らのものとが逆になっていることに注意してください。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --rerere-autoupdate
* --no-rerere-autoupdate  
    rerere メカニズムが現在の競合で記録された解決を再利用して作業ツリー内のファイルを更新した後、解決の結果でインデックスも更新できるようにします。 --no-rerere-autoupdate は、別の git add で結果をインデックスにコミットする前に、rerere が行ったことを再確認し、潜在的なミスマージをキャッチするための良い方法です。
* -S[<keyid>]
* --gpg-sign[=<keyid>]
* --no-gpg-sign  
    GPG署名コミット。 keyid 引数はオプションで、デフォルトはコミッター ID です。 指定する場合は、スペースなしでオプションに貼り付ける必要があります。 --no-gpg-sign は、commit.gpgSign 構成変数と以前の --gpg-sign の両方を取り消すのに役立ちます。
* -q
* --quiet  
    --no-stat を意味します。
* -v
* --verbose  
    冗長にします。 --stat を意味します。
* --stat  
    最後のリベース以降にアップストリームで変更された内容の diffstat を表示します。 diffstat は、構成オプション rebase.stat によっても制御されます。
* -n
* --no-stat  
    リベース プロセスの一部として diffstat を表示しないでください。
* --no-verify  
    このオプションは、リベース前のフックをバイパスします。 githooksも参照してください。
* --verify  
    pre-rebase フックの実行を許可します (デフォルト)。 このオプションを使用すると、--no-verify をオーバーライドできます。 githooksも参照してください。
* -C\<n>  
    各変更の前後で周囲のコンテキストの少なくとも <n> 行が一致していることを確認します。 存在する周囲のコンテキストの行が少ない場合は、すべてが一致する必要があります。 デフォルトでは、コンテキストは決して無視されません。 --apply を意味します。<br><br>以下の「互換性のないオプション」も参照してください。
* --no-ff
* --force-rebase
* -f  
    変更されていないコミットを早送りするのではなく、リベースされたすべてのコミットを個別に再生します。 これにより、リベースされたブランチの履歴全体が新しいコミットで構成されることが保証されます。<br><br>このオプションは、トピック ブランチのマージを元に戻した後に役立つ場合があります。このオプションは、新しいコミットでトピック ブランチを再作成するため、「バージョンを元に戻す」必要なく、正常に再マージできます (「revert-a-faulty-merge How-To」を参照)。 詳細）。
* --fork-point
* --no-fork-point  
    どのコミットが \<branch> によって導入されたかを計算するときに、reflog を使用して、\<upstream> と \<branch> の間のより適切な共通祖先を見つけます。<br><br>--fork-point がアクティブな場合、リベースするコミットのセットを計算するために \<upstream> の代わりに fork_point が使用されます。fork_point は git merge-base --fork-point \<upstream> \<branch> コマンドの結果です ( git-merge-base[1] を参照してください)。 fork_point が空になった場合、\<upstream> がフォールバックとして使用されます。<br><br>コマンドラインで \<upstream> または --keep-base が指定された場合、デフォルトは --no-fork-point になり、それ以外の場合はデフォルトは --fork-point になります。 git-config の rebase.forkpoint も参照してください。<br><br>ブランチが \<upstream> に基づいていたが、\<upstream> が巻き戻され、ブランチに削除されたコミットが含まれている場合、このオプションを --keep-base とともに使用して、ブランチからそれらのコミットを削除できます。<br><br>以下の「互換性のないオプション」も参照してください。
* --ignore-whitespace  
    違いを調整する場合は、空白の違いを無視してください。 現在、各バックエンドはこの動作の近似を実装しています。
    * apply backend  
        パッチを適用するときは、コンテキスト行の空白の変更を無視してください。 残念ながら、これは、パッチによって置き換えられる「古い」行が既存のファイルと空白のみが異なる場合、パッチ適用は成功する代わりにマージ競合が発生することを意味します。
    * merge backend  
        マージ時に、空白のみが変更された行は変更されていないものとして処理されます。 残念ながら、これは、たとえ相手側に競合する変更がなかったとしても、空白などを変更することを目的としたパッチ ハンクはすべて削除されることを意味します。
 * --whitespace=\<option>  
    このフラグは、パッチを適用する git apply プログラム (git-apply[1] を参照) に渡されます。 --apply を意味します。<br><br>以下の「互換性のないオプション」も参照してください。
* --committer-date-is-author-date  
    現在の時刻をコミッターの日付として使用する代わりに、リベースされるコミットの作成者の日付をコミッターの日付として使用します。 このオプションは --force-rebase を意味します。
* --ignore-date
* --reset-author-date  
    元のコミットの作成者日付を使用する代わりに、現在の時刻をリベースされたコミットの作成者日付として使用します。 このオプションは --force-rebase を意味します。<br><br>以下の「互換性のないオプション」も参照してください。
* --signoff  
    リベースされたすべてのコミットにサインオフ トレーラーを追加します。 --interactive が指定されている場合、選択、編集、または言い換えがマークされたコミットのみにトレーラーが追加されることに注意してください。<br><br>以下の「互換性のないオプション」も参照してください。
* -i
* --interactive  
    リベースされるコミットのリストを作成します。 リベースする前に、ユーザーがそのリストを編集できるようにします。 このモードはコミットの分割にも使用できます (下記の「コミットの分割」を参照)。<br><br>コミット リストの形式は、構成オプション rebase.instructionFormat を設定することで変更できます。 カスタマイズされた命令フォーマットには、長いコミット ハッシュが自動的にフォーマットの先頭に追加されます。<br><br>以下の「互換性のないオプション」も参照してください。
* -r
* --rebase-merges[=(rebase-cousins|no-rebase-cousins)] 
    デフォルトでは、リベースは単純にマージコミットを todo リストから削除し、リベースされたコミットを単一の線形ブランチに配置します。 --rebase-merges を使用すると、リベースはマージ コミットを再作成することで、リベースされるコミット内の分岐構造を保存しようとします。 これらのマージ コミットで解決されたマージ競合または手動修正は、手動で解決/再適用する必要があります。<br><br>デフォルト、または no-rebase-cousins が指定された場合、直接の祖先として \<upstream> を持たないコミットは、元の分岐点を保持します。つまり、git-log[1] の --ancestry- によって除外されるコミットです。 path オプションはデフォルトで元の祖先を保持します。 rebase-cousins モードがオンになっている場合、そのようなコミットは代わりに \<upstream> (または指定されている場合は \<onto>) にリベースされます。<br><br>現時点では、ort マージ戦略を使用してマージ コミットを再作成することのみが可能です。 さまざまなマージ戦略は、明示的に exec git merge -s \<strategy> [...] コマンドを介してのみ使用できます。<br><br>以下の「マージのリベースと非互換オプション」も参照してください。
* -x \<cmd>
* --exec \<cmd>  
    最終履歴にコミットを作成する各行の後に「exec \<cmd>」を追加します。 \<cmd> は 1 つ以上のシェル コマンドとして解釈されます。 コマンドが失敗すると、終了コード 1 が表示されてリベースが中断されます。<br><br>--exec の 1 つのインスタンスを複数のコマンドとともに使用することにより、複数のコマンドを実行できます。  
    ```
    git rebase -i --exec "cmd1 && cmd2 && ..."
    ```
    or by giving more than one --exec:  
    ```
    git rebase -i --exec "cmd1" --exec "cmd2" --exec ...
    ```
    --autosquash を使用すると、実行行は中間コミットに追加されず、各スカッシュ/フィックスアップ シリーズの最後にのみ表示されます。<br><br>これは内部的に --interactive 機構を使用しますが、明示的な --interactive なしでも実行できます。<br><br>以下の「互換性のないオプション」も参照してください。
* --root  
    \<upstream> で制限するのではなく、\<branch> から到達可能なすべてのコミットをリベースします。 これにより、ブランチ上のルート コミットをリベースできるようになります。<br><br>以下の「互換性のないオプション」も参照してください。
