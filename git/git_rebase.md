# git-rebase - Reapply commits on top of another base tip

[Git - git-rebase Documentation](https://git-scm.com/docs/git-rebase)

## オプション

* --onto \<newbase>  
    新しいコミットを作成する開始点。 --onto オプションが指定されていない場合、開始点は <upstream> です。 既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。<br><br>特殊なケースとして、マージ ベースが 1 つしかない場合、A と B のマージ ベースのショートカットとして "A...B" を使用できます。 A と B のいずれかを省略できます。省略した場合、デフォルトで HEAD になります。
* --keep-base  
    \<upstream> と \<branch> のマージ ベースに新しいコミットを作成する開始点を設定します。 git rebase --keep-base \<upstream> \<branch> を実行することは、 git rebase --reapply-cherry-picks --no-fork-point --onto \<upstream>...\<branch> \<upstream> < を実行することと同等です<br><br>このオプションは、アップストリーム ブランチ上で機能を開発している場合に役立ちます。 機能の作業中は、上流のブランチが前進する可能性があり、上流の上でリベースを続けるのは最善の考えではなく、ベース コミットをそのままにしておくのが最善の方法ではない可能性があります。 基本コミットは変更されていないため、このオプションは --reapply-cherry-picks を意味し、コミットが失われないようにします。<br><br>このオプションと --fork-point の両方が \<upstream> と \<branch> の間のマージ ベースを見つけますが、このオプションは新しいコミットが作成される開始点としてマージ ベースを使用しますが、 --fork-point はマージを使用します。 base を使用して、リベースされるコミットのセットを決定します。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* \<upstream>  
    比較する上流ブランチ。 既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。 デフォルトは、現在のブランチ用に構成されたアップストリームです。
* \<branch>  
    ワーキングブランチ; デフォルトはHEADです。
* --apply  
    適用戦略を使用してリベースします (内部で git-am を呼び出します)。 マージ バックエンドが適用バックエンドが行うすべての処理を行うと、このオプションは将来ノーオペレーションになる可能性があります。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --empty={drop,keep,ask}  
    開始するために空ではなく、アップストリーム コミットのクリーン チェリー ピックではないが、リベース後に空になるコミットを処理する方法 (既にアップストリームの変更のサブセットが含まれているため)。 drop (デフォルト) では、空になったコミットは破棄されます。 keep を使用すると、そのようなコミットが保持されます。 ask (--interactive で暗示) を使用すると、空のコミットが適用されるとリベースが停止し、それを削除するか、ファイルをさらに編集するか、空の変更をコミットするかを選択できます。 --exec などのその他のオプションは、-i/--interactive が明示的に指定されていない限り、デフォルトのドロップを使用します。<br><br>空で始まるコミットは保持され ( --no-keep-empty が指定されていない限り)、クリーンなチェリーピックであるコミット ( git log --cherry-mark ... によって決定される) は検出され、ドロップされることに注意してください。 予備ステップ ( --reapply-cherry-picks または --keep-base が渡されない限り)。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --no-keep-empty
* --keep-empty
    リベースの前に空で始まるコミット (つまり、親から何も変更しないコミット) を結果に保持しないでください。 そのようなコミットを作成するには、 --allow-empty オーバーライド フラグを git commit に渡す必要があるため、デフォルトでは、空で始まるコミットを保持します。これは、ユーザーが非常に意図的にそのようなコミットを作成しているため、それを保持したいことを示します。<br><br>インタラクティブなリベースを起動し、不要なコミットに対応する行を削除するだけで、空で始まるコミットを取り除くことができるため、このフラグの使用はおそらくまれです。 このフラグは、外部ツールが多くの空のコミットを生成し、それらをすべて削除したい場合などに便利なショートカットとして存在します。<br><br>空で開始せず、リベース後に空になるコミットについては、 --empty フラグを参照してください。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --reapply-cherry-picks
* --no-reapply-cherry-picks  
    プリエンプティブにドロップするのではなく、アップストリーム コミットのすべてのクリーン チェリー ピックを再適用します。 (これらのコミットがリベース後に空になった場合、すでにアップストリームの変更のサブセットが含まれているため、それらに対する動作は --empty フラグによって制御されます。)<br><br>--keep-base がない場合 (または --no-reapply-cherry-picks が指定されている場合)、これらのコミットは自動的に削除されます。 これにはすべてのアップストリーム コミットを読み取る必要があるため、読み取る必要があるアップストリーム コミットが多数あるリポジトリではコストがかかる可能性があります。 マージ バックエンドを使用する場合、ドロップされたコミットごとに警告が発行されます (--quiet が指定されていない場合)。 advice.skipedCherryPicks が false に設定されていない限り、アドバイスも発行されます (git-config を参照)。<br><br>--reapply-cherry-picks を使用すると、rebase はすべてのアップストリーム コミットの読み取りを省略できるため、パフォーマンスが向上する可能性があります。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --allow-empty-message  
    ノーオペレーション。 以前は、空のメッセージを含むコミットのリベースは失敗し、このオプションはその動作をオーバーライドし、空のメッセージを含むコミットをリベースできるようにしていました。 空のメッセージでコミットしてもリベースが停止しないようになりました。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* -m
* --merge  
    マージ戦略を使用してリベースします (デフォルト)。<br><br>リベース マージは、\<upstream> ブランチの最上位の作業ブランチから各コミットを再生することによって機能することに注意してください。 このため、マージの競合が発生した場合、私たちとして報告された側は、これまでにリベースされたシリーズであり、\<upstream> で始まり、彼らの側が作業ブランチです。 つまり、側面が交換されます。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* -s \<strategy>
* --strategy=\<strategy>  
    デフォルトの ort の代わりに、指定されたマージ戦略を使用します。 これは --merge を意味します。<br><br>git rebase は、指定された戦略を使用して \<upstream> ブランチの最上位の作業ブランチから各コミットを再生するため、ours 戦略を使用すると、\<branch> からすべてのパッチが単純に空になりますが、これはほとんど意味がありません。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* -X \<strategy-option>
* --strategy-option=\<strategy-option>  
    \<strategy-option> をマージ戦略に渡します。 これは --merge を意味し、戦略が指定されていない場合は -s ort を意味します。 上記の -m オプションのように、私たちのものと彼らのものとが逆になっていることに注意してください。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --rerere-autoupdate
* --no-rerere-autoupdate  
    rerere メカニズムが現在の競合で記録された解決を再利用して作業ツリー内のファイルを更新した後、解決の結果でインデックスも更新できるようにします。 --no-rerere-autoupdate は、別の git add で結果をインデックスにコミットする前に、rerere が行ったことを再確認し、潜在的なミスマージをキャッチするための良い方法です。
* -S[<keyid>]
* --gpg-sign[=<keyid>]
* --no-gpg-sign  
    GPG署名コミット。 keyid 引数はオプションで、デフォルトはコミッター ID です。 指定する場合は、スペースなしでオプションに貼り付ける必要があります。 --no-gpg-sign は、commit.gpgSign 構成変数と以前の --gpg-sign の両方を取り消すのに役立ちます。
* -q
* --quiet  
    --no-stat を意味します。
* -v
* --verbose  
    冗長にします。 --stat を意味します。
* --stat  
    最後のリベース以降にアップストリームで変更された内容の diffstat を表示します。 diffstat は、構成オプション rebase.stat によっても制御されます。
* -n
* --no-stat  
    リベース プロセスの一部として diffstat を表示しないでください。
* --no-verify  
    このオプションは、リベース前のフックをバイパスします。 githooksも参照してください。
* --verify  
    pre-rebase フックの実行を許可します (デフォルト)。 このオプションを使用すると、--no-verify をオーバーライドできます。 githooksも参照してください。
* -C\<n>  
    各変更の前後で周囲のコンテキストの少なくとも <n> 行が一致していることを確認します。 存在する周囲のコンテキストの行が少ない場合は、すべてが一致する必要があります。 デフォルトでは、コンテキストは決して無視されません。 --apply を意味します。<br><br>以下の「互換性のないオプション」も参照してください。
* --no-ff
* --force-rebase
* -f  
    変更されていないコミットを早送りするのではなく、リベースされたすべてのコミットを個別に再生します。 これにより、リベースされたブランチの履歴全体が新しいコミットで構成されることが保証されます。<br><br>このオプションは、トピック ブランチのマージを元に戻した後に役立つ場合があります。このオプションは、新しいコミットでトピック ブランチを再作成するため、「バージョンを元に戻す」必要なく、正常に再マージできます (「revert-a-faulty-merge How-To」を参照)。 詳細）。
* --fork-point
* --no-fork-point  
    どのコミットが \<branch> によって導入されたかを計算するときに、reflog を使用して、\<upstream> と \<branch> の間のより適切な共通祖先を見つけます。<br><br>--fork-point がアクティブな場合、リベースするコミットのセットを計算するために \<upstream> の代わりに fork_point が使用されます。fork_point は git merge-base --fork-point \<upstream> \<branch> コマンドの結果です ( git-merge-base[1] を参照してください)。 fork_point が空になった場合、\<upstream> がフォールバックとして使用されます。<br><br>コマンドラインで \<upstream> または --keep-base が指定された場合、デフォルトは --no-fork-point になり、それ以外の場合はデフォルトは --fork-point になります。 git-config の rebase.forkpoint も参照してください。<br><br>ブランチが \<upstream> に基づいていたが、\<upstream> が巻き戻され、ブランチに削除されたコミットが含まれている場合、このオプションを --keep-base とともに使用して、ブランチからそれらのコミットを削除できます。<br><br>以下の「互換性のないオプション」も参照してください。
* --ignore-whitespace  
    違いを調整する場合は、空白の違いを無視してください。 現在、各バックエンドはこの動作の近似を実装しています。
    * apply backend  
        パッチを適用するときは、コンテキスト行の空白の変更を無視してください。 残念ながら、これは、パッチによって置き換えられる「古い」行が既存のファイルと空白のみが異なる場合、パッチ適用は成功する代わりにマージ競合が発生することを意味します。
    * merge backend  
        マージ時に、空白のみが変更された行は変更されていないものとして処理されます。 残念ながら、これは、たとえ相手側に競合する変更がなかったとしても、空白などを変更することを目的としたパッチ ハンクはすべて削除されることを意味します。
 * --whitespace=\<option>  
    このフラグは、パッチを適用する git apply プログラム (git-apply[1] を参照) に渡されます。 --apply を意味します。<br><br>以下の「互換性のないオプション」も参照してください。
* --committer-date-is-author-date  
    現在の時刻をコミッターの日付として使用する代わりに、リベースされるコミットの作成者の日付をコミッターの日付として使用します。 このオプションは --force-rebase を意味します。
* --ignore-date
* --reset-author-date  
    元のコミットの作成者日付を使用する代わりに、現在の時刻をリベースされたコミットの作成者日付として使用します。 このオプションは --force-rebase を意味します。<br><br>以下の「互換性のないオプション」も参照してください。
* --signoff  
    リベースされたすべてのコミットにサインオフ トレーラーを追加します。 --interactive が指定されている場合、選択、編集、または言い換えがマークされたコミットのみにトレーラーが追加されることに注意してください。<br><br>以下の「互換性のないオプション」も参照してください。
* -i
* --interactive  
    リベースされるコミットのリストを作成します。 リベースする前に、ユーザーがそのリストを編集できるようにします。 このモードはコミットの分割にも使用できます (下記の「コミットの分割」を参照)。<br><br>コミット リストの形式は、構成オプション rebase.instructionFormat を設定することで変更できます。 カスタマイズされた命令フォーマットには、長いコミット ハッシュが自動的にフォーマットの先頭に追加されます。<br><br>以下の「互換性のないオプション」も参照してください。
* -r
* --rebase-merges[=(rebase-cousins|no-rebase-cousins)] 
    デフォルトでは、リベースは単純にマージコミットを todo リストから削除し、リベースされたコミットを単一の線形ブランチに配置します。 --rebase-merges を使用すると、リベースはマージ コミットを再作成することで、リベースされるコミット内の分岐構造を保存しようとします。 これらのマージ コミットで解決されたマージ競合または手動修正は、手動で解決/再適用する必要があります。<br><br>デフォルト、または no-rebase-cousins が指定された場合、直接の祖先として \<upstream> を持たないコミットは、元の分岐点を保持します。つまり、git-log[1] の --ancestry- によって除外されるコミットです。 path オプションはデフォルトで元の祖先を保持します。 rebase-cousins モードがオンになっている場合、そのようなコミットは代わりに \<upstream> (または指定されている場合は \<onto>) にリベースされます。<br><br>現時点では、ort マージ戦略を使用してマージ コミットを再作成することのみが可能です。 さまざまなマージ戦略は、明示的に exec git merge -s \<strategy> [...] コマンドを介してのみ使用できます。<br><br>以下の「マージのリベースと非互換オプション」も参照してください。
* -x \<cmd>
* --exec \<cmd>  
    最終履歴にコミットを作成する各行の後に「exec \<cmd>」を追加します。 \<cmd> は 1 つ以上のシェル コマンドとして解釈されます。 コマンドが失敗すると、終了コード 1 が表示されてリベースが中断されます。<br><br>--exec の 1 つのインスタンスを複数のコマンドとともに使用することにより、複数のコマンドを実行できます。  
    ```
    git rebase -i --exec "cmd1 && cmd2 && ..."
    ```
    or by giving more than one --exec:  
    ```
    git rebase -i --exec "cmd1" --exec "cmd2" --exec ...
    ```
    --autosquash を使用すると、実行行は中間コミットに追加されず、各スカッシュ/フィックスアップ シリーズの最後にのみ表示されます。<br><br>これは内部的に --interactive 機構を使用しますが、明示的な --interactive なしでも実行できます。<br><br>以下の「互換性のないオプション」も参照してください。
* --root  
    \<upstream> で制限するのではなく、\<branch> から到達可能なすべてのコミットをリベースします。 これにより、ブランチ上のルート コミットをリベースできるようになります。<br><br>以下の「互換性のないオプション」も参照してください。
* --autosquash
* --no-autosquash  
    コミット ログ メッセージが「squash! …」または「fixup! …」または「amend! …」で始まり、同じ ... に一致するコミットが todo リストにすでに存在する場合、todo を自動的に変更します。 rebase -i のリストを変更して、スカッシュとしてマークされたコミットが変更対象のコミットの直後にくるようにし、移動されたコミットのアクションをそれぞれ pick から squash または fixup または fixup -C に変更します。 コミットの件名が一致する場合、または ... がコミットのハッシュを参照している場合、コミットは ... と一致します。 フォールバックとして、コミット対象の部分一致も機能します。 fixup/amend/squash コミットを作成する推奨方法は、git-commit[1] の --fixup、--fixup=amend: または --fixup=reword:、および --squash オプションをそれぞれ使用することです。<br><br>構成変数 rebase.autoSquash を使用して --autosquash オプションがデフォルトで有効になっている場合、このオプションを使用してこの設定をオーバーライドして無効にすることができます。<br><br>以下の「互換性のないオプション」も参照してください。
* --autostash
* --no-autostash  
    操作の開始前に一時的なスタッシュ エントリを自動的に作成し、操作の終了後にそれを適用します。 これは、ダーティなワークツリーに対してリベースを実行できることを意味します。 ただし、使用には注意してください。リベースが成功した後の最終的な stash アプリケーションでは、重大な競合が発生する可能性があります。
* --reschedule-failed-exec
* --no-reschedule-failed-exec  
    失敗した実行コマンドを自動的に再スケジュールします。 これは対話モード (または --exec オプションが指定された場合) でのみ意味を持ちます。<br><br>このオプションはリベースの開始後に適用されますが、このオプションは、rebase.rescheduleFailedExec 設定 (以下の git-config[1] または「CONFIGURATION」を参照) またはこのオプションが提供されているかどうかに基づいて、開始時にリベース全体に設定されます。 そうしないと、開始時の明示的な --no-reschedule-failed-exec は、rebase.rescheduleFailedExec=true 設定の存在によって上書きされます。
* --update-refs
* --no-update-refs  
    リベース中のコミットを指すブランチを自動的に強制更新します。 ワークツリーでチェックアウトされたブランチは、この方法では更新されません。<br><br>構成変数 rebase.updateRefs が設定されている場合、このオプションを使用してこの設定をオーバーライドし、無効にすることができます。<br><br>以下の「互換性のないオプション」も参照してください。

### 互換性のないオプション
次のオプション:
* --apply
* --whitespace
* -C

### 次のオプションとは互換性がありません
* --merge
* --strategy
* --strategy-option
* --autosquash
* --rebase-merges
* --interactive
* --exec
* --no-keep-empty
* --empty=
* --[no-]reapply-cherry-picks when used without --keep-base
* --update-refs
* --root when used without --onto

### さらに、次のオプションのペアには互換性がありません
* --keep-base and --onto
* --keep-base and --root
* --fork-point and --root

## BEHAVIORAL DIFFERENCES

git rebase には、apply と merge という 2 つの主要なバックエンドがあります。 (適用バックエンドは以前は am バックエンドとして知られていましたが、この名前は名詞ではなく動詞のように見えるため混乱を引き起こしました。また、マージ バックエンドは以前はインタラクティブ バックエンドとして知られていましたが、現在は 非対話型の場合も同様です。両方とも、それぞれをサポートする下位レベルの機能に基づいて名前が変更されました。) これら 2 つのバックエンドの動作には、いくつかの微妙な違いがあります。

### Empty commits
残念ながら、適用バックエンドは意図的に空のコミット、つまり空で開始されたコミットをドロップしますが、実際にはこのようなことはまれです。 また、空になったコミットも削除され、この動作を制御するオプションはありません。

マージ バックエンドは、デフォルトで意図的に空のコミットを保持します (ただし、-i を使用すると、ToDo リスト エディターで空としてマークされるか、--no-keep-empty を使用して自動的に削除できます)。

適用バックエンドと同様に、デフォルトでは、マージ バックエンドは、-i/--interactive が指定されていない限り、空になるコミットを削除します (この場合、バックエンドは停止し、ユーザーに何をするかを尋ねます)。 マージ バックエンドには、空になったコミットの処理動作を変更するための --empty={drop,keep,ask} オプションもあります。

### Directory rename detection

正確なツリー情報が不足しているため (パッチで入手可能な限られた情報を使用して偽の祖先を構築することに起因)、適用バックエンドではディレクトリ名の変更検出が無効になっています。 ディレクトリ名の変更検出が無効になっているということは、履歴の一方がディレクトリの名前を変更し、もう一方が古いディレクトリに新しいファイルを追加した場合、リベース時に新しいファイルが警告なしで古いディレクトリに残されることを意味します。 これらのファイルを新しいディレクトリに移動します。

ディレクトリ名の変更検出はマージ バックエンドと連携して機能し、そのような場合に警告を表示します。

### Context

適用バックエンドは、(内部で format-patch を呼び出して) 一連のパッチを作成し、(内部で am を呼び出して) パッチを順番に適用することによって機能します。 パッチは複数のハンクで構成され、それぞれに行番号、コンテキスト領域、および実際の変更が含まれます。 相手側がファイルの以前に行を挿入または削除している可能性が高いため、行番号はある程度曖昧にして取得する必要があります。 コンテキスト領域は、変更を正しい行に適用するために行番号を調整する方法を見つけるのに役立ちます。 ただし、コードの複数の領域に同じ周囲のコンテキスト行がある場合、間違ったものが選択される可能性があります。 これにより、競合が報告されずにコミットが誤って再適用されるという現実のケースがあります。 diff.context をより大きな値に設定すると、このようなタイプの問題は回避できる可能性がありますが、偽の競合が発生する可能性が高くなります (適用するには一致するコンテキストの行数が増えるため)。

マージ バックエンドは、関連する各ファイルの完全なコピーを操作して、この種の問題からファイルを隔離します。

### Labelling of conflicts markers

コンテンツの競合がある場合、マージ機構は、コンテンツの生成元のコミットをそれぞれの側の競合マーカーに注釈付けしようとします。 適用バックエンドは、リベースされたコミットとその親に関する元の情報を削除する (代わりに、生成されたパッチ内の限られた情報に基づいて新しい偽のコミットを生成する) ため、それらのコミットを識別することはできません。 代わりに、コミットの概要にフォールバックする必要があります。 また、merge.conflictStyle が diff3 または zdiff3 に設定されている場合、適用バックエンドは「構築されたマージ ベース」を使用してマージ ベースのコンテンツにラベルを付けるため、マージ ベースのコミットに関する情報はまったく提供されません。

マージ バックエンドは履歴の両側で完全なコミットを処理するため、そのような制限はありません。

### Hooks

従来、適用バックエンドはコミット後フックを呼び出していませんでしたが、マージ バックエンドは呼び出していました。 どちらもチェックアウト後のフックを呼び出していますが、マージ バックエンドは出力を抑制しています。 さらに、両方のバックエンドは、中間コミットや最終コミットではなく、リベースの開始点コミットでチェックアウト後のフックのみを呼び出します。 いずれの場合も、これらのフックの呼び出しは設計によるものではなく、実装の偶然によるものでした (両方のバックエンドは元々シェル スクリプトとして実装されており、フックを呼び出す git checkout や git commit などの他のコマンドをたまたま呼び出していました)。 どちらのバックエンドも同じ動作をするはずですが、どちらが正しいかは完全には明らかではありません。 将来的には、リベースでこれらのフックのいずれかの呼び出しを停止する予定です。

### Interruptability

適用バックエンドには、タイミングの悪い割り込みによる安全性の問題があります。 ユーザーがリベースを中止しようとして間違ったタイミングで Ctrl-C を押した場合、リベースは後続の git rebase --abort では中止できない状態になる可能性があります。 マージ バックエンドには同じ欠点はないようです。 (詳細については、https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/ を参照してください。)

### Commit Rewording

Rebasing中に競合が発生すると、Rebaseは停止し、ユーザーに解決を求めます。 競合を解決しながら顕著な変更を加える必要がある場合があるため、競合が解決され、ユーザーがGit Rebaseを実行した後、Rebaseはエディターを開き、ユーザーにコミットメッセージの更新を依頼する必要があります。 マージバックエンドはこれを行い、適用バックエンドは元のコミットメッセージを盲目的に適用します。

### Miscellaneous differences

ほとんどの人にとっておそらく重要ではないと思われる動作上の違いがさらにいくつかありますが、完全を期すために言及されています。

* Reflog: 2 つのバックエンドは、reflog で行われた変更を説明するときに異なる表現を使用しますが、どちらも「リベース」という単語を使用します。
* 進行状況メッセージ、情報メッセージ、およびエラー メッセージ: 2 つのバックエンドは、若干異なる進行状況メッセージと情報メッセージを提供します。 また、適用バックエンドはエラー メッセージ (「ファイルが上書きされます…」など) を stdout に書き込み、マージ バックエンドはエラー メッセージを stderr に書き込みます。
* 状態ディレクトリ: 2 つのバックエンドは、.git/ の下の異なるディレクトリに状態を保持します。

### MERGE STRATEGIES

マージ メカニズム (git merge および git pull コマンド) では、-s オプションを使用してバックエンド マージ戦略を選択できます。 一部の戦略は独自のオプションを取ることもでき、 -X\<option> 引数を git merge や git pull に渡すことで渡すことができます。

* ort  
    これは、1 つのブランチをプルまたはマージする場合のデフォルトのマージ戦略です。 この戦略では、3 ウェイ マージ アルゴリズムを使用して 2 つのヘッドのみを解決できます。 3 方向マージに使用できる共通の祖先が複数ある場合、共通の祖先のマージされたツリーが作成され、それが 3 方向マージの参照ツリーとして使用されます。 これにより、Linux 2.6 カーネル開発履歴から取得した実際のマージ コミットに対して行われたテストにより、ミスマージを引き起こすことなく、マージ競合が減少することが報告されています。 さらに、この戦略は名前変更を伴うマージを検出して処理できます。 検出されたコピーは使用されません。 このアルゴリズムの名前は頭字語 (「Ostensibly Recursive’s Twin」) であり、以前のデフォルト アルゴリズムである再帰の代替として作成されたという事実に由来しています。<br><br>ort 戦略には次のオプションがあります。

    * ours
    このオプションを使用すると、競合するハンクが私たちのバージョンを優先して自動的にきれいに解決されます。 こちら側と競合しない他のツリーからの変更は、マージ結果に反映されます。 バイナリ ファイルの場合、内容全体が当社側から取得されます。<br><br>これを、他のツリーに含まれる内容をまったく考慮しない私たちのマージ戦略と混同しないでください。 それは他のツリーが行ったすべてを破棄し、私たちの歴史にはその中で起こったすべてが含まれていることを宣言します。

    * theirs
    これは私たちのものとは逆です。 私たちのものとは異なり、このマージ オプションを混同するようなマージ戦略がないことに注意してください。

     * ignore-space-change
     * ignore-all-space
     * ignore-space-at-eol
     * ignore-cr-at-eol  
     3 者間マージのために、指定されたタイプの空白変更を含む行を変更されていないものとして扱います。 行に対する他の変更と混合した空白の変更は無視されません。 git-diff[1] -b、-w、--ignore-space-at-eol、および --ignore-cr-at-eol も参照してください。

        * バージョンが行に空白の変更を導入するだけの場合は、当社のバージョンが使用されます。
        * 私たちのバージョンに空白の変更が導入されていても、そのバージョンに大幅な変更が含まれている場合は、そのバージョンが使用されます。
        * それ以外の場合、マージは通常の方法で続行されます。

    * renormalize
    これにより、3 方向マージを解決するときに、ファイルの 3 つのステージすべての仮想チェックアウトとチェックインが実行されます。 このオプションは、異なるクリーン フィルターまたは行末正規化ルールを持つブランチをマージするときに使用することを目的としています。 詳細については、gitattributes[5] の「異なるチェックイン/チェックアウト属性を持つブランチのマージ」を参照してください。
    * no-renormalize
    再正規化オプションを無効にします。 これは、merge.renormalize 構成変数をオーバーライドします。
    * find-renames[=\<n>]
    名前変更の検出をオンにし、オプションで類似性のしきい値を設定します。 これがデフォルトです。 これは、merge.renames 構成変数をオーバーライドします。 git-diff --find-renames も参照してください。
    * rename-threshold=\<n>
    find-renames=\<n> の非推奨の同義語。
    * subtree[=\<path>]
    このオプションは、サブツリー戦略のより高度な形式であり、この戦略では、マージ時に 2 つのツリーを互いに一致させるためにどのようにシフトする必要があるかを推測します。 代わりに、指定されたパスに接頭辞が付けられ (または先頭から削除され)、2 つのツリーの形状が一致するようになります。

* recursive  
これは、3 ウェイ マージ アルゴリズムを使用して 2 つのヘッドのみを解決できます。 3 方向マージに使用できる共通の祖先が複数ある場合、共通の祖先のマージされたツリーが作成され、それが 3 方向マージの参照ツリーとして使用されます。 これにより、Linux 2.6 カーネル開発履歴から取得した実際のマージ コミットに対して行われたテストにより、ミスマージを引き起こすことなく、マージ競合が減少することが報告されています。 さらに、名前の変更を伴うマージを検出して処理できます。 検出されたコピーは使用されません。 これは、Git v0.99.9k から v2.33.0 まで 2 つのヘッドを解決するためのデフォルトの戦略でした。<br><br>再帰的戦略では、ort と同じオプションが使用されます。 ただし、ort が無視する追加のオプションが 3 つあります (上記には記載されていません)。これらは再帰的戦略で役立つ可能性があります。
    * patience
