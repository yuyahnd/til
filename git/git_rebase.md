# git-rebase - Reapply commits on top of another base tip

[Git - git-rebase Documentation](https://git-scm.com/docs/git-rebase)

## オプション

* --onto \<newbase>  
    新しいコミットを作成する開始点。 --onto オプションが指定されていない場合、開始点は <upstream> です。 既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。<br><br>特殊なケースとして、マージ ベースが 1 つしかない場合、A と B のマージ ベースのショートカットとして "A...B" を使用できます。 A と B のいずれかを省略できます。省略した場合、デフォルトで HEAD になります。
* --keep-base  
    \<upstream> と \<branch> のマージ ベースに新しいコミットを作成する開始点を設定します。 git rebase --keep-base \<upstream> \<branch> を実行することは、 git rebase --reapply-cherry-picks --no-fork-point --onto \<upstream>...\<branch> \<upstream> < を実行することと同等です<br><br>このオプションは、アップストリーム ブランチ上で機能を開発している場合に役立ちます。 機能の作業中は、上流のブランチが前進する可能性があり、上流の上でリベースを続けるのは最善の考えではなく、ベース コミットをそのままにしておくのが最善の方法ではない可能性があります。 基本コミットは変更されていないため、このオプションは --reapply-cherry-picks を意味し、コミットが失われないようにします。<br><br>このオプションと --fork-point の両方が \<upstream> と \<branch> の間のマージ ベースを見つけますが、このオプションは新しいコミットが作成される開始点としてマージ ベースを使用しますが、 --fork-point はマージを使用します。 base を使用して、リベースされるコミットのセットを決定します。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* \<upstream>  
    比較する上流ブランチ。 既存のブランチ名だけでなく、任意の有効なコミットである可能性があります。 デフォルトは、現在のブランチ用に構成されたアップストリームです。
* \<branch>  
    ワーキングブランチ; デフォルトはHEADです。
* --apply  
    適用戦略を使用してリベースします (内部で git-am を呼び出します)。 マージ バックエンドが適用バックエンドが行うすべての処理を行うと、このオプションは将来ノーオペレーションになる可能性があります。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --empty={drop,keep,ask}  
    開始するために空ではなく、アップストリーム コミットのクリーン チェリー ピックではないが、リベース後に空になるコミットを処理する方法 (既にアップストリームの変更のサブセットが含まれているため)。 drop (デフォルト) では、空になったコミットは破棄されます。 keep を使用すると、そのようなコミットが保持されます。 ask (--interactive で暗示) を使用すると、空のコミットが適用されるとリベースが停止し、それを削除するか、ファイルをさらに編集するか、空の変更をコミットするかを選択できます。 --exec などのその他のオプションは、-i/--interactive が明示的に指定されていない限り、デフォルトのドロップを使用します。<br><br>空で始まるコミットは保持され ( --no-keep-empty が指定されていない限り)、クリーンなチェリーピックであるコミット ( git log --cherry-mark ... によって決定される) は検出され、ドロップされることに注意してください。 予備ステップ ( --reapply-cherry-picks または --keep-base が渡されない限り)。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --no-keep-empty
* --keep-empty
    リベースの前に空で始まるコミット (つまり、親から何も変更しないコミット) を結果に保持しないでください。 そのようなコミットを作成するには、 --allow-empty オーバーライド フラグを git commit に渡す必要があるため、デフォルトでは、空で始まるコミットを保持します。これは、ユーザーが非常に意図的にそのようなコミットを作成しているため、それを保持したいことを示します。<br><br>インタラクティブなリベースを起動し、不要なコミットに対応する行を削除するだけで、空で始まるコミットを取り除くことができるため、このフラグの使用はおそらくまれです。 このフラグは、外部ツールが多くの空のコミットを生成し、それらをすべて削除したい場合などに便利なショートカットとして存在します。<br><br>空で開始せず、リベース後に空になるコミットについては、 --empty フラグを参照してください。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --reapply-cherry-picks
* --no-reapply-cherry-picks  
    プリエンプティブにドロップするのではなく、アップストリーム コミットのすべてのクリーン チェリー ピックを再適用します。 (これらのコミットがリベース後に空になった場合、すでにアップストリームの変更のサブセットが含まれているため、それらに対する動作は --empty フラグによって制御されます。)<br><br>--keep-base がない場合 (または --no-reapply-cherry-picks が指定されている場合)、これらのコミットは自動的に削除されます。 これにはすべてのアップストリーム コミットを読み取る必要があるため、読み取る必要があるアップストリーム コミットが多数あるリポジトリではコストがかかる可能性があります。 マージ バックエンドを使用する場合、ドロップされたコミットごとに警告が発行されます (--quiet が指定されていない場合)。 advice.skipedCherryPicks が false に設定されていない限り、アドバイスも発行されます (git-config を参照)。<br><br>--reapply-cherry-picks を使用すると、rebase はすべてのアップストリーム コミットの読み取りを省略できるため、パフォーマンスが向上する可能性があります。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --allow-empty-message  
    ノーオペレーション。 以前は、空のメッセージを含むコミットのリベースは失敗し、このオプションはその動作をオーバーライドし、空のメッセージを含むコミットをリベースできるようにしていました。 空のメッセージでコミットしてもリベースが停止しないようになりました。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* -m
* --merge  
    マージ戦略を使用してリベースします (デフォルト)。<br><br>リベース マージは、\<upstream> ブランチの最上位の作業ブランチから各コミットを再生することによって機能することに注意してください。 このため、マージの競合が発生した場合、私たちとして報告された側は、これまでにリベースされたシリーズであり、\<upstream> で始まり、彼らの側が作業ブランチです。 つまり、側面が交換されます。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* -s \<strategy>
* --strategy=\<strategy>  
    デフォルトの ort の代わりに、指定されたマージ戦略を使用します。 これは --merge を意味します。<br><br>git rebase は、指定された戦略を使用して \<upstream> ブランチの最上位の作業ブランチから各コミットを再生するため、ours 戦略を使用すると、\<branch> からすべてのパッチが単純に空になりますが、これはほとんど意味がありません。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* -X \<strategy-option>
* --strategy-option=\<strategy-option>  
    \<strategy-option> をマージ戦略に渡します。 これは --merge を意味し、戦略が指定されていない場合は -s ort を意味します。 上記の -m オプションのように、私たちのものと彼らのものとが逆になっていることに注意してください。<br><br>以下の INCOMPATIBLE OPTIONS も参照してください。
* --rerere-autoupdate
* --no-rerere-autoupdate  
    rerere メカニズムが現在の競合で記録された解決を再利用して作業ツリー内のファイルを更新した後、解決の結果でインデックスも更新できるようにします。 --no-rerere-autoupdate は、別の git add で結果をインデックスにコミットする前に、rerere が行ったことを再確認し、潜在的なミスマージをキャッチするための良い方法です。
* -S[<keyid>]
* --gpg-sign[=<keyid>]
* --no-gpg-sign  
    GPG署名コミット。 keyid 引数はオプションで、デフォルトはコミッター ID です。 指定する場合は、スペースなしでオプションに貼り付ける必要があります。 --no-gpg-sign は、commit.gpgSign 構成変数と以前の --gpg-sign の両方を取り消すのに役立ちます。
* -q
* --quiet  
    --no-stat を意味します。
* -v
* --verbose  
    冗長にします。 --stat を意味します。
* --stat  
    最後のリベース以降にアップストリームで変更された内容の diffstat を表示します。 diffstat は、構成オプション rebase.stat によっても制御されます。
* -n
* --no-stat  
    リベース プロセスの一部として diffstat を表示しないでください。
* --no-verify  
    このオプションは、リベース前のフックをバイパスします。 githooksも参照してください。
* --verify  
    pre-rebase フックの実行を許可します (デフォルト)。 このオプションを使用すると、--no-verify をオーバーライドできます。 githooksも参照してください。
