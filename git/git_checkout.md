# git-checkout - Switch branches or restore working tree files

[Git - git-checkout Documentation](https://git-scm.com/docs/git-checkout)


## 説明

|コマンド|説明|
|:--|:--|
|git checkout [\<branch>]|\<branch>での作業の準備をするには、作業ツリーのインデックスとファイルを更新し、ブランチにHEADをポイントして、\<branch>に切り替えます。 \<branch>にコミットできるように、作業ツリー内のファイルに対するローカルの変更は保持されます。<br><br>\<branch>が見つからないが、一致する名前を持つ1つのリモート（\<remote>と呼びます）に追跡ブランチが存在し、-no-guessが指定されていない場合は、次と同等として扱います。|
|git checkout -b|-B \<new-branch> [\<start-point>]|-bを指定すると、git-branch が呼び出されてからチェックアウトされたかのように、新しいブランチが作成されます。 この場合、gitブランチに渡される--trackまたは--no-trackオプションを使用できます。 便宜上、-bなしの--trackはブランチの作成を意味します。 以下の--trackの説明を参照してください。|
|git checkout --detach [\<branch>]<br>git checkout [--detach] \<commit>|\<commit>でHEADをデタッチし（「DETACHEDHEAD」セクションを参照）、作業ツリー内のインデックスとファイルを更新することにより、\<commit>上で作業する準備をします。 作業ツリー内のファイルへのローカル変更は保持されるため、結果の作業ツリーは、コミットに記録された状態とローカル変更になります。<br><br>\<commit>引数がブランチ名の場合、-detachオプションを使用して、ブランチの先端でHEADをデタッチできます（git checkout \<branch>は、HEADをデタッチせずにそのブランチをチェックアウトします）。<br><br><branch>を省略すると、現在のブランチの先端にあるHEADが切り離されます。|
|git checkout [-f\|--ours\|--theirs\|-m\|--conflict=\<style>] [<tree-ish>] [--] \<pathspec>…​ |pathspecに一致するファイルの内容を上書きします。 \<tree-ish>（ほとんどの場合コミット）が指定されていない場合は、作業ツリーをインデックスの内容で上書きします。 \<tree-ish>を指定したら、インデックスと作業ツリーの両方を\<tree-ish>の内容で上書きします。<br><br>以前にマージに失敗したため、インデックスにマージされていないエントリが含まれている可能性があります。 デフォルトでは、インデックスからそのようなエントリをチェックアウトしようとすると、チェックアウト操作は失敗し、何もチェックアウトされません。 -fを使用すると、これらのマージされていないエントリは無視されます。 マージの特定の側からのコンテンツは、-oursまたは--theirsを使用してインデックスからチェックアウトできます。 -mを使用すると、作業ツリーファイルに加えられた変更を破棄して、元の競合するマージ結果を再作成できます。|
|git checkout (-p\|--patch) [\<tree-ish>] [--] [\<pathspec>…​]|これは前のモードと似ていますが、インタラクティブインターフェイスを使用して「差分」出力を表示し、結果で使用するハンクを選択できます。 --patchオプションの説明については、以下を参照してください。|

## オプション

|オプション|説明|
|:--|:--|
|-q<br>--quiet|フィードバックメッセージを抑制します。|
|--progress<br>--no-progress|--quietが指定されていない限り、進行状況は、端末に接続されている場合、デフォルトで標準エラーストリームに報告されます。 このフラグは、-quietに関係なく、端末に接続されていない場合でも進行状況のレポートを有効にします。|
|-f<br>--force|ブランチを切り替えるときは、インデックスまたは作業ツリーがHEADと異なっていても、追跡されていないファイルが途中にある場合でも続行します。 これは、ローカルの変更や、邪魔になっている追跡されていないファイルやディレクトリを破棄するために使用されます。<br><br>インデックスからパスをチェックアウトするときは、マージされていないエントリで失敗しないでください。 代わりに、マージされていないエントリは無視されます。|
|--ours<br>--theirs|インデックスからパスをチェックアウトするときは、ステージ＃2（私たち）または＃3（それら）でマージされていないパスをチェックしてください。<br><br>gitrebaseとgitpull --rebaseの間、私たちと彼らが交換されたように見えるかもしれないことに注意してください。 --oursは、変更がリベースされているブランチのバージョンを提供し、-theirsは、リベースされている作業を保持しているブランチのバージョンを提供します。<br><br>これは、リモートでの履歴を共有の正規の履歴として扱い、リベースするブランチで行われた作業を統合されるサードパーティの作業として扱うワークフローでリベースが使用され、一時的にその役割を引き受けるためです。 リベース中の正規の歴史のキーパーの。 カノニカルヒストリーのキーパーとして、リモートからの履歴を私たちのもの（つまり「共有されたカノニカルヒストリー」）として表示する必要があります。 ）。|
|-b \<new-branch>|\<new-branch>という名前の新しいブランチを作成し、\<start-point>で開始します。 詳細については、git-branch を参照してください。|
|-B \<new-branch>|ブランチ\<new-branch>を作成し、\<start-point>で開始します。 すでに存在する場合は、\<start-point>にリセットします。 これは、「-f」を指定して「gitbranch」を実行するのと同じです。 詳細については、git-branch を参照してください。|
|-t<br>--track[=(direct\|inherit)]|新しいブランチを作成するときは、「アップストリーム」構成をセットアップします。 詳細については、git-branch [1]の「--track」を参照してください。<br><br>-bオプションが指定されていない場合、新しいブランチの名前は、対応するリモート用に構成されたrefspecのローカル部分を調べ、最初の部分を「*」まで削除することにより、リモート追跡ブランチから取得されます。 "。 これは、origin / hack（またはremotes / origin / hack、さらにはrefs / remotes / origin / hack）から分岐するときに、ローカル分岐としてhackを使用するように指示します。 指定された名前にスラッシュがない場合、または上記の推測の結果が空の名前になる場合、推測は中止されます。 このような場合は、-bを使用して明示的に名前を付けることができます。|
|--no-track|branch.autoSetupMerge構成変数がtrueであっても、「アップストリーム」構成をセットアップしないでください。|
|--guess<br>--no-guess|\<branch>が見つからないが、名前が一致する1つのリモート（\<remote>と呼びます）に追跡ブランチが存在する場合は、次のように扱います。|
|-l|新しいブランチのreflogを作成します。 詳細については、git-branch を参照してください。 |
|-d<br>--detach|ブランチをチェックアウトして作業するのではなく、検査と破棄可能な実験のためのコミットをチェックアウトします。 これは、\<commit>がブランチ名でない場合のgit checkout \<commit>のデフォルトの動作です。 詳細については、以下の「デタッチドヘッド」セクションを参照してください。|
|--orphan \<new-branch>|\<start-point>から開始した\<new-branch>という名前の新しい孤立したブランチを作成し、それに切り替えます。 この新しいブランチで行われた最初のコミットには親がなく、他のすべてのブランチとコミットから完全に切断された新しい履歴のルートになります。|
|--ignore-skip-worktree-bits|スパースチェックアウトモードでは、git checkout- \<paths>は、$ GIT_DIR / info / sparse-checkoutの\<paths>とスパースパターンに一致するエントリのみを更新します。 このオプションは、スパースパターンを無視し、\<paths>内のファイルを追加し直します。|
|-m<br>--merge|ブランチを切り替えるときに、現在のブランチと切り替え先のブランチの間で異なる1つ以上のファイルにローカルの変更がある場合、コマンドは、コンテキストでの変更を保持するためにブランチの切り替えを拒否します。 ただし、このオプションを使用すると、現在のブランチ、作業ツリーの内容、および新しいブランチの間の3方向のマージが実行され、新しいブランチに移動します。<br><br>マージの競合が発生すると、競合するパスのインデックスエントリはマージされないままになり、競合を解決し、解決されたパスをgit add（またはマージによってパスが削除される場合はgit rm）でマークする必要があります。<br><br>インデックスからパスをチェックアウトする場合、このオプションを使用すると、指定したパスで競合するマージを再作成できます。<br><br>--mergeを使用してブランチを切り替えると、段階的な変更が失われる可能性があります。|
|--conflict=\<style>|上記の--mergeオプションと同じですが、競合するハンクの表示方法を変更し、merge.conflictStyle構成変数をオーバーライドします。 可能な値は、「merge」（デフォルト）、「diff3」、および「zdiff3」です。|
|-p<br>--patch|\<tree-ish>（または指定されていない場合はインデックス）と作業ツリーの違いでハンクをインタラクティブに選択します。 選択されたハンクは、作業ツリーに逆に適用されます（\<tree-ish>が指定されている場合は、インデックス）。<br><br>これは、git checkout -pを使用して、現在の作業ツリーから編集を選択的に破棄できることを意味します。 --patchモードの操作方法については、git-add [1]の「インタラクティブモード」セクションを参照してください。<br><br>このオプションはデフォルトでオーバーレイなしモードを使用し（--overlayも参照）、現在オーバーレイモードをサポートしていないことに注意してください。|
