# git-fetch - Download objects and refs from another repository

[Git - git-fetch Documentation](https://git-scm.com/docs/git-fetch)

## オプション

|オプション|説明|
|:--|:--|
|--all|すべてのリモートを取得します。|
|-a<br>--append|取得した ref の ref 名とオブジェクト名を .git/FETCH_HEAD の既存のコンテンツに追加します。 このオプションがないと、.git/FETCH_HEAD の古いデータが上書きされます。|
|--atomic|アトミック トランザクションを使用して、ローカル参照を更新します。 すべての参照が更新されるか、エラーが発生した場合、参照は更新されません。|
|--depth=\<depth>|各リモート ブランチ履歴の先端から指定された数のコミットにフェッチを制限します。 --depth=\<depth> オプションを使用して git clone によって作成された浅いリポジトリにフェッチする場合 (git-clone[1] を参照)、指定されたコミット数まで履歴を深くするか、短くします。 深化されたコミットのタグは取得されません。|
|--deepen=\<depth>|--depth と同様ですが、各リモート ブランチ履歴の先端からではなく、現在の浅い境界からのコミット数を指定する点が異なります。|
|--shallow-since=\<date>|浅いリポジトリの履歴を深くまたは短くして、\<date> 以降に到達可能なすべてのコミットを含めます。|
|--shallow-exclude=\<revision>|浅いリポジトリの履歴を深くまたは短くして、指定されたリモート ブランチまたはタグから到達可能なコミットを除外します。 このオプションは複数回指定できます。|
|--unshallow|ソース リポジトリが完成したら、浅いリポジトリを完全なリポジトリに変換し、浅いリポジトリによって課されるすべての制限を取り除きます。<br><br>ソース リポジトリが浅い場合は、現在のリポジトリがソース リポジトリと同じ履歴を持つように、可能な限り取得します。|
|--update-shallow|デフォルトでは、浅いリポジトリからフェッチする場合、git fetch は .git/shallow の更新が必要な参照を拒否します。 このオプションは .git/shallow を更新し、そのような参照を受け入れます。|
|--negotiation-tip=\<commit\|glob>|デフォルトでは、Git はすべてのローカル ref から到達可能なコミットをサーバーに報告し、受信するパックファイルのサイズを縮小しようとして、共通のコミットを見つけます。 指定した場合、Git は指定されたヒントから到達可能なコミットのみを報告します。 これは、フェッチされるアップストリーム ref と共通のコミットを持つ可能性が高いローカル ref をユーザーが知っている場合に、フェッチを高速化するのに役立ちます。|
|--negotiate-only|サーバーから何も取得せず、代わりに提供された --negotiation-tip=* 引数の祖先を出力します。これはサーバーと共通です。<br><br>これは --recurse-submodules=[yes\|on-demand] と互換性がありません。 内部的には、これは push.negotiate オプションを実装するために使用されます。git-config を参照してください。|
|--dry-run|変更を加えることなく、何が行われるかを示します。|
|--[no-]write-fetch-head|$GIT_DIR 直下の FETCH_HEAD ファイルにフェッチされたリモート参照のリストを書き込みます。 これがデフォルトです。 コマンドラインから --no-write-fetch-head を渡すと、ファイルを書き込まないように Git に指示します。 --dry-run オプションでは、ファイルは書き込まれません。|
|-f<br>--force|\<src>:\<dst> refspec で git fetch を使用すると、以下の \<refspec> の部分で説明するように、ローカル ブランチの更新を拒否する場合があります。 このオプションは、そのチェックをオーバーライドします。|
|-k<br>--keep|ダウンロードしたパックを保持します。|
|--multiple|複数の \<repository> および \<group> 引数を指定できるようにします。 \<refspec> は指定できません。|
|--[no-]auto-maintenance<br>--[no-]auto-gc|最後に git maintenance run --auto を実行して、必要に応じてリポジトリの自動メンテナンスを実行します。 (--[no-]auto-gc は同義語です。) これはデフォルトで有効になっています。|
|--[no-]write-commit-graph|フェッチ後にコミットグラフを書き込みます。 これは、構成設定の fetch.writeCommitGraph をオーバーライドします。|
|--prefetch|構成された refspec を変更して、すべての参照を refs/prefetch/ 名前空間に配置します。 git-maintenance のプリフェッチ タスクを参照してください。|
|-p<br>--prune|取得する前に、リモートに存在しなくなったリモート追跡参照をすべて削除します。 デフォルトのタグの自動追従または --tags オプションが原因でのみタグがフェッチされる場合、タグはプルーニングの対象ではありません。 ただし、明示的な refspec が原因でタグがフェッチされた場合 (コマンド ラインまたはリモート構成で、たとえば、リモートが --mirror オプションで複製された場合)、それらもプルーニングの対象になります。 --prune-tags を提供することは、タグ refspec を提供するための省略形です。<br><br>詳細については、以下の PRUNING セクションを参照してください。|
|-P<br>--prune-tags|--prune が有効になっている場合は、フェッチする前に、リモートに存在しなくなったローカル タグをすべて削除します。 このオプションは、作成されたローカル参照 (ローカル タグ) をすべて削除する --prune とは異なり、より慎重に使用する必要があります。 このオプションは、 --prune とともに明示的なタグ refspec を提供するための省略形です。これについては、そのドキュメントの説明を参照してください。<br><br>詳細については、以下の PRUNING セクションを参照してください。|
|-n<br>--no-tags|デフォルトでは、リモート リポジトリからダウンロードされたオブジェクトを指すタグが取得され、ローカルに保存されます。 このオプションは、この自動タグ フォローを無効にします。 リモートのデフォルトの動作は、remote.\<name>.tagOpt 設定で指定できます。 git-config を参照してください。|
