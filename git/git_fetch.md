# git-fetch - Download objects and refs from another repository

[Git - git-fetch Documentation](https://git-scm.com/docs/git-fetch)

## オプション

|オプション|説明|
|:--|:--|
|--all|すべてのリモートを取得します。|
|-a<br>--append|取得した ref の ref 名とオブジェクト名を .git/FETCH_HEAD の既存のコンテンツに追加します。 このオプションがないと、.git/FETCH_HEAD の古いデータが上書きされます。|
|--atomic|アトミック トランザクションを使用して、ローカル参照を更新します。 すべての参照が更新されるか、エラーが発生した場合、参照は更新されません。|
|--depth=\<depth>|各リモート ブランチ履歴の先端から指定された数のコミットにフェッチを制限します。 --depth=\<depth> オプションを使用して git clone によって作成された浅いリポジトリにフェッチする場合 (git-clone[1] を参照)、指定されたコミット数まで履歴を深くするか、短くします。 深化されたコミットのタグは取得されません。|
|--deepen=\<depth>|--depth と同様ですが、各リモート ブランチ履歴の先端からではなく、現在の浅い境界からのコミット数を指定する点が異なります。|
|--shallow-since=\<date>|浅いリポジトリの履歴を深くまたは短くして、\<date> 以降に到達可能なすべてのコミットを含めます。|
|--shallow-exclude=\<revision>|浅いリポジトリの履歴を深くまたは短くして、指定されたリモート ブランチまたはタグから到達可能なコミットを除外します。 このオプションは複数回指定できます。|
|--unshallow|ソース リポジトリが完成したら、浅いリポジトリを完全なリポジトリに変換し、浅いリポジトリによって課されるすべての制限を取り除きます。<br><br>ソース リポジトリが浅い場合は、現在のリポジトリがソース リポジトリと同じ履歴を持つように、可能な限り取得します。|
|--update-shallow|デフォルトでは、浅いリポジトリからフェッチする場合、git fetch は .git/shallow の更新が必要な参照を拒否します。 このオプションは .git/shallow を更新し、そのような参照を受け入れます。|
|--negotiation-tip=\<commit\|glob>|デフォルトでは、Git はすべてのローカル ref から到達可能なコミットをサーバーに報告し、受信するパックファイルのサイズを縮小しようとして、共通のコミットを見つけます。 指定した場合、Git は指定されたヒントから到達可能なコミットのみを報告します。 これは、フェッチされるアップストリーム ref と共通のコミットを持つ可能性が高いローカル ref をユーザーが知っている場合に、フェッチを高速化するのに役立ちます。|
|--negotiate-only|サーバーから何も取得せず、代わりに提供された --negotiation-tip=* 引数の祖先を出力します。これはサーバーと共通です。<br><br>これは --recurse-submodules=[yes\|on-demand] と互換性がありません。 内部的には、これは push.negotiate オプションを実装するために使用されます。git-config を参照してください。|
|--dry-run|変更を加えることなく、何が行われるかを示します。|
|--[no-]write-fetch-head|$GIT_DIR 直下の FETCH_HEAD ファイルにフェッチされたリモート参照のリストを書き込みます。 これがデフォルトです。 コマンドラインから --no-write-fetch-head を渡すと、ファイルを書き込まないように Git に指示します。 --dry-run オプションでは、ファイルは書き込まれません。|
|-f<br>--force|\<src>:\<dst> refspec で git fetch を使用すると、以下の \<refspec> の部分で説明するように、ローカル ブランチの更新を拒否する場合があります。 このオプションは、そのチェックをオーバーライドします。|
|-k<br>--keep|ダウンロードしたパックを保持します。|
|--multiple|複数の \<repository> および \<group> 引数を指定できるようにします。 \<refspec> は指定できません。|
|--[no-]auto-maintenance<br>--[no-]auto-gc|最後に git maintenance run --auto を実行して、必要に応じてリポジトリの自動メンテナンスを実行します。 (--[no-]auto-gc は同義語です。) これはデフォルトで有効になっています。|
|--[no-]write-commit-graph|フェッチ後にコミットグラフを書き込みます。 これは、構成設定の fetch.writeCommitGraph をオーバーライドします。|
|--prefetch|構成された refspec を変更して、すべての参照を refs/prefetch/ 名前空間に配置します。 git-maintenance のプリフェッチ タスクを参照してください。|
|-p<br>--prune|取得する前に、リモートに存在しなくなったリモート追跡参照をすべて削除します。 デフォルトのタグの自動追従または --tags オプションが原因でのみタグがフェッチされる場合、タグはプルーニングの対象ではありません。 ただし、明示的な refspec が原因でタグがフェッチされた場合 (コマンド ラインまたはリモート構成で、たとえば、リモートが --mirror オプションで複製された場合)、それらもプルーニングの対象になります。 --prune-tags を提供することは、タグ refspec を提供するための省略形です。<br><br>詳細については、以下の PRUNING セクションを参照してください。|
|-P<br>--prune-tags|--prune が有効になっている場合は、フェッチする前に、リモートに存在しなくなったローカル タグをすべて削除します。 このオプションは、作成されたローカル参照 (ローカル タグ) をすべて削除する --prune とは異なり、より慎重に使用する必要があります。 このオプションは、 --prune とともに明示的なタグ refspec を提供するための省略形です。これについては、そのドキュメントの説明を参照してください。<br><br>詳細については、以下の PRUNING セクションを参照してください。|
|-n<br>--no-tags|デフォルトでは、リモート リポジトリからダウンロードされたオブジェクトを指すタグが取得され、ローカルに保存されます。 このオプションは、この自動タグ フォローを無効にします。 リモートのデフォルトの動作は、remote.\<name>.tagOpt 設定で指定できます。 git-config を参照してください。|
|--refetch|すでにローカルに存在するコミットおよび関連オブジェクトの転送を避けるためにサーバーと交渉する代わりに、このオプションは新しいクローンのようにすべてのオブジェクトをフェッチします。 これを使用して、構成から部分クローン フィルターを再適用するか、フィルター定義が変更されたときに --filter= を使用します。 フェッチ後の自動メンテナンスにより、オブジェクト データベース パックの統合が実行され、重複オブジェクトが削除されます。|
|--refmap=\<refspec>|コマンドラインにリストされた ref をフェッチするときは、リモート リポジトリの remote.*.fetch 構成変数の値の代わりに、指定された refspec (複数回指定可能) を使用して、ref をリモート追跡ブランチにマップします。 --refmap オプションに空の \<refspec> を指定すると、Git は構成された refspecs を無視し、コマンドライン引数として指定された refspecs に完全に依存します。 詳細については、「構成済みのリモート追跡ブランチ」のセクションを参照してください。|
|-t<br>--tags|リモートからすべてのタグをフェッチします (つまり、リモート タグ refs/tags/* を同じ名前のローカル タグにフェッチします)。 このオプションを単独で使用すると、 --prune が使用されていても、タグはプルーニングの対象になりません (ただし、タグが明示的な refspec の宛先でもある場合は、いずれにしてもタグをプルーニングできます。 --prune を参照してください)。|
|--recurse-submodules[=yes\|on-demand\|no]|このオプションは、サブモジュールの新しいコミットも取得する必要があるかどうか、およびどのような条件で取得するかを制御します。 サブモジュールを再帰する場合、 git fetch は常に「変更された」サブモジュール、つまり、新しくフェッチされたスーパープロジェクト コミットによって参照されるが、ローカル サブモジュール クローンにないコミットを持つサブモジュールをフェッチしようとします。 変更されたサブモジュールは、ローカルに存在する限りフェッチできます。 $GIT_DIR/modules/ 内 (gitsubmodules を参照); アップストリームが新しいサブモジュールを追加した場合、そのサブモジュールは複製されるまで取得できません。 git サブモジュールの更新による。|
|-j<br>--jobs=\<n>|すべての形式のフェッチに使用される並列の子の数。<br><br>--multiple オプションが指定された場合、異なるリモートが並行して取得されます。 複数のサブモジュールがフェッチされる場合、それらは並行してフェッチされます。 それらを個別に制御するには、構成設定 fetch.parallel および submodule.fetchJobs を使用します (git-config を参照)。<br><br>通常、並列再帰およびマルチリモート フェッチは高速になります。 デフォルトでは、フェッチは並列ではなく順次実行されます。|
|--no-recurse-submodules|サブモジュールの再帰的フェッチを無効にします (これは、 --recurse-submodules=no オプションを使用するのと同じ効果があります)。|
|--set-upstream|リモートが正常に取得された場合は、引数なしの git-pull およびその他のコマンドで使用されるアップストリーム (追跡) 参照を追加します。 詳細については、git-config の branch.\<name>.merge と branch.\<name>.remote を参照してください。|
|--submodule-prefix=\<path>|「Fetching submodule foo」などの情報メッセージに出力されるパスの先頭に \<path> を追加します。 このオプションは、サブモジュールを再帰するときに内部的に使用されます。|
|--recurse-submodules-default=[yes\|on-demand]|このオプションは、 --recurse-submodules オプションに負でないデフォルト値を一時的に提供するために内部的に使用されます。 fetch のサブモジュール再帰を構成する他のすべての方法 (gitmodules や git-config での設定など) は、 --[no-]recurse-submodules を直接指定する場合と同様に、このオプションをオーバーライドします。|
|-u<br>--update-head-ok|デフォルトでは、git fetch は現在のブランチに対応する head の更新を拒否します。 このフラグはチェックを無効にします。 これは、git pull が git fetch と通信するための純粋な内部使用のためのものであり、独自の Porcelain を実装しない限り、使用することは想定されていません。|
|--upload-pack \<upload-pack>|与えられ、フェッチ元のリポジトリが git fetch-pack によって処理される場合、 --exec=\<upload-pack> がコマンドに渡され、相手側で実行されるコマンドのデフォルト以外のパスを指定します。|
|-q<br>--quiet|--quiet を git-fetch-pack に渡し、内部で使用されるその他の git コマンドを無音にします。 進行状況は標準エラー ストリームには報告されません。|
|-v<br>--verbose|冗長にします。|
|--progress|進行状況は、-q が指定されていない限り、端末に接続されている場合、デフォルトで標準エラー ストリームに報告されます。 このフラグは、標準エラー ストリームが端末に向けられていない場合でも、進行状況を強制します。|
