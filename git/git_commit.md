# git commit

[Git - git-commit Documentation](https://git-scm.com/docs/git-commit)

## オプション

|オプション|説明|
|:--|:--|
|-a<br>--all|変更および削除されたファイルを自動的にステージングするようにコマンドに指示しますが、Gitに通知していない新しいファイルは影響を受けません。|
|-p<br>--patch|インタラクティブなパッチ選択インターフェイスを使用して、コミットする変更を選択します。 詳細については、git-add [1]を参照してください。|
|-C \<commit\><br>--reuse-message=\<commit\>|既存のコミットオブジェクトを取得し、コミットを作成するときにログメッセージと作成者情報（タイムスタンプを含む）を再利用します|
|-c \<commit\><br>--reedit-message=\<commit\>|-Cと同様ですが、-cを使用するとエディターが呼び出されるため、ユーザーはコミットメッセージをさらに編集できます。|
|--fixup=[(amend\|reword):]\<commit\>|git rebase --autosquashを適用すると、\<commit\>を「修正」する新しいコミットを作成します。 プレーン--fixup = \<commit\>は「fixup！」を作成します \<commit\>の内容を変更するが、ログメッセージは変更されないままにするcommit。 --fixup = amend：\<commit\>も同様ですが、「amend！」を作成します。 \<commit\>のログメッセージを「amend！」のログメッセージに置き換えるcommit。 専念。 --fixup = reword：\<commit\>は「修正」を作成します！ \<commit\>のログメッセージを独自のログメッセージに置き換えるが、\<commit\>の内容は変更しないcommit。<br><br>プレーン--fixup = \<commit\>によって作成されたコミットには、「fixup！」で構成されるサブジェクトがあります。 \<commit\>の件名が続き、git rebase--autosquashによって特別に認識されます。 -mオプションは、作成されたコミットのログメッセージを補足するために使用できますが、「修正」が完了すると、追加のコメントは破棄されます。 commitは、git rebase--autosquashによって\<commit\>に押しつぶされます。<br><br>--fixup = amend：\<commit\>によって作成されたコミットも同様ですが、その件名の前に「amend！」が付けられます。 \<commit\>のログメッセージが「amend！」のログメッセージにコピーされます。 コミットしてエディターで開くと、調整できます。 git rebase --autosquashが「修正」を押しつぶすと、 \<commit\>にコミットすると、\<commit\>のログメッセージは「amend！」からの洗練されたログメッセージに置き換えられます。 専念。 「修正！」のエラーです。 --allow-empty-messageが指定されていない限り、コミットのログメッセージは空になります。<br><br>--fixup = reword：\<commit\>は--fixup = amend：\<commit\>-onlyの省略形です。 それは「修正」を作成します！ ログメッセージのみでコミットします（インデックスにステージングされた変更は無視します）。 git rebase --autosquashによって押しつぶされると、他の変更を加えることなく、\<commit\>のログメッセージが置き換えられます。<br><br>どちらも「修正！」 また、「修正」もしません。 git rebase --autosquashによって適用されると、\<commit\>の変更オーサーシップをコミットします。 詳細については、git-rebase [1]を参照してください。|
|--squash=\<commit\>|rebase--autosquashで使用するコミットメッセージを作成します。 コミットメッセージの件名は、プレフィックスが「squash！」の指定されたコミットから取得されます。 追加のコミットメッセージオプション（-m / -c / -C / -F）とともに使用できます。 詳細については、git-rebase [1]を参照してください。|
|--reset-author|-C / -c / -amendオプションとともに使用する場合、または競合するチェリーピックの後にコミットする場合は、結果のコミットの作成者がコミッターに属することを宣言します。 これにより、作成者のタイムスタンプも更新されます。|
|--short|ドライランを行うときは、出力を短い形式で提供します。--dry-runを意味します。|
|--branch|短い形式でもブランチと追跡情報を表示します。|
|--porcelain|ドライランを行うときは、磁器対応の形式で出力を提供します。 詳細については、git-status [1]を参照してください。 --dry-runを意味します。|
|--long|ドライランを行うときは、出力をロングフォーマットで提供します。 --dry-runを意味します。|
|-z<br>--null|ショートまたは磁器のステータス出力を表示する場合は、ファイル名を逐語的に出力し、LFではなくNULでエントリを終了します。 形式が指定されていない場合は、-porcelain出力形式を意味します。 -zオプションを指定しない場合、構成変数core.quotePathで説明されているように、「異常な」文字を含むファイル名が引用符で囲まれます（git-config [1]を参照）。|
|-F \<file\><br>--file=\<file\>|指定されたファイルからコミットメッセージを取得します。 -を使用して、標準入力からメッセージを読み取ります。|
|--author=\<author\>|コミット作成者をオーバーライドします。 標準のAU Thor \<author@example.com\>形式を使用して明示的な作成者を指定します。 それ以外の場合、\<author\>はパターンであると見なされ、その作成者による既存のコミットを検索するために使用されます（つまり、rev-list --all -i --author = \<author\>）。 次に、コミットの作成者は、最初に見つかったそのようなコミットからコピーされます。|
|--date=\<date\>|コミットで使用された作成者の日付を上書きします。|
|-m \<msg\><br>--message=\<msg\>|指定された<msg>をコミットメッセージとして使用します。 複数の-mオプションが指定されている場合、それらの値は個別の段落として連結されます。<br><br>-mオプションは、-c、-C、および-Fと相互に排他的です。|
|-t \<file\><br>--template=\<file\>|コミットメッセージを編集するときは、指定されたファイルの内容でエディターを起動します。 commit.template構成変数は、このオプションをコマンドに暗黙的に与えるためによく使用されます。 このメカニズムは、メッセージに何をどの順序で書き込むかについてのヒントを参加者に案内したいプロジェクトで使用できます。 ユーザーがメッセージを編集せずにエディターを終了すると、コミットは中止されます。 これは、メッセージが他の手段で提供された場合には効果がありません。 -mまたは-Fオプションを使用します。|
|-s<br>--signoff<br>--no-signoff|コミットログメッセージの最後に、コミッターによるサインオフバイトレーラーを追加します。 サインオフの意味は、コミットしているプロジェクトによって異なります。 たとえば、コミッターがプロジェクトのライセンスに基づいて作品を提出する権利を持っていることを証明したり、開発者の原産地証明書などの寄稿者の代表に同意したりする場合があります。 （LinuxカーネルおよびGitプロジェクトで使用されるものについては、"http://developercertificate.org"を参照してください。）プロジェクトでサインオフがどのように使用されるかを理解するには、貢献しているプロジェクトのドキュメントまたはリーダーシップを参照してください。<br><br>--no-signoffオプションを使用すると、コマンドラインで以前の--signoffオプションを無効にすることができます。|
|--trailer \<token\>[(=\|:)\<value\>]|トレーラーとして適用する必要がある（\<token\>、\<value\>）ペアを指定します。 （例：git commit --trailer "Signed-off-by：CO Mitter \ \<committer@example.com\>" --trailer "Helped-by：CO Mitter \ \<committer@example.com\>"は "Signed- コミットメッセージへの「off-by」トレーラーと「Helped-by」トレーラー。）trailer。*構成変数（git-interpret-trailers）を使用して、重複したトレーラーを省略するかどうかを定義できます。 各トレーラーが表示されるトレーラーの実行、およびその他の詳細。|
|-n<br>--no-verify|このオプションは、pre-commitフックとcommit-msgフックをバイパスします。 githooks も参照してください。|
|--allow-empty|通常、唯一の親コミットとまったく同じツリーを持つコミットを記録することは間違いであり、コマンドはそのようなコミットを行うことを防ぎます。 このオプションは安全性をバイパスし、主に外部SCMインターフェイススクリプトで使用するためのものです。|
|--allow-empty-message|--allow-emptyと同様に、このコマンドは主に外部SCMインターフェイススクリプトで使用するためのものです。 git-commit-tree のような配管コマンドを使用せずに、空のコミットメッセージでコミットを作成できます。|
|--squash=\<commit\>|rebase--autosquashで使用するコミットメッセージを作成します。 コミットメッセージの件名は、プレフィックスが「squash！」の指定されたコミットから取得されます。 追加のコミットメッセージオプション（-m / -c / -C / -F）とともに使用できます。 詳細については、git-rebase を参照してください。|
|--reset-author|-C / -c / -amendオプションとともに使用する場合、または競合するチェリーピックの後にコミットする場合は、結果のコミットの作成者がコミッターに属することを宣言します。 これにより、作成者のタイムスタンプも更新されます。|
|--short|ドライランを行うときは、出力を短い形式で提供します。 詳細については、git-status を参照してください。 --dry-runを意味します。|
|--branch|短い形式でもブランチと追跡情報を表示します。|
|--porcelain|ドライランを行うときは、磁器対応の形式で出力を提供します。 詳細については、git-status を参照してください。 --dry-runを意味します。|
|--long|ドライランを行うときは、出力をロングフォーマットで提供します。 --dry-runを意味します。|
|-z<br>--null|ショートまたは磁器のステータス出力を表示する場合は、ファイル名を逐語的に出力し、LFではなくNULでエントリを終了します。 形式が指定されていない場合は、-porcelain出力形式を意味します。 -zオプションを指定しない場合、構成変数core.quotePathで説明されているように、「異常な」文字を含むファイル名が引用符で囲まれます（git-config を参照）。|
|-F \<file\><br>--file=\<file\>|指定されたファイルからコミットメッセージを取得します。 -を使用して、標準入力からメッセージを読み取ります。|
|--author=\<author\>|コミット作成者をオーバーライドします。 標準のAU Thor \<author@example.com\>形式を使用して明示的な作成者を指定します。 それ以外の場合、<author>はパターンであると見なされ、その作成者による既存のコミットを検索するために使用されます（つまり、rev-list --all -i --author = <author>）。 次に、コミットの作成者は、最初に見つかったそのようなコミットからコピーされます。|
|--date=\<date\>|コミットで使用された作成者の日付を上書きします。|
|-m \<msg><br>--message=\<msg>|指定された\<msg>をコミットメッセージとして使用します。 複数の-mオプションが指定されている場合、それらの値は個別の段落として連結されます。<br>-mオプションは、-c、-C、および-Fと相互に排他的です。|
|-t \<file><br>--template=\<file>|コミットメッセージを編集するときは、指定されたファイルの内容でエディターを起動します。 commit.template構成変数は、このオプションをコマンドに暗黙的に与えるためによく使用されます。 このメカニズムは、メッセージに何をどの順序で書き込むかについてのヒントを参加者に案内したいプロジェクトで使用できます。 ユーザーがメッセージを編集せずにエディターを終了すると、コミットは中止されます。 これは、メッセージが他の手段で提供された場合には効果がありません。 -mまたは-Fオプションを使用します。|
|-s<br>--signoff<br>--no-signoff|コミットログメッセージの最後に、コミッターによるサインオフバイトレーラーを追加します。 サインオフの意味は、コミットしているプロジェクトによって異なります。 たとえば、コミッターがプロジェクトのライセンスに基づいて作品を提出する権利を持っていることを証明したり、開発者の原産地証明書などの寄稿者の代表に同意したりする場合があります。 （LinuxカーネルおよびGitプロジェクトで使用されるものについては、http：//developercertificate.orgを参照してください。）プロジェクトでサインオフがどのように使用されるかを理解するには、貢献しているプロジェクトのドキュメントまたはリーダーシップを参照してください。<br><br>--no-signoffオプションを使用すると、コマンドラインで以前の--signoffオプションを無効にすることができます。|
|--trailer \<token>[(=\|:)\<value>]|トレーラーとして適用する必要がある（\<token>、\<value>）ペアを指定します。 （例：git commit --trailer "Signed-off-by：CO Mitter \ <committer@example.com>" --trailer "Helped-by：CO Mitter \ <committer@example.com>"は "Signed- コミットメッセージへの「off-by」トレーラーと「Helped-by」トレーラー。）trailer。*構成変数（git-interpret-trailers）を使用して、重複したトレーラーを省略するかどうかを定義できます。 各トレーラーが表示されるトレーラーの実行、およびその他の詳細。|
|-n<br>--no-verify|このオプションは、pre-commitフックとcommit-msgフックをバイパスします。 githooks も参照してください。|
|--allow-empty|通常、唯一の親コミットとまったく同じツリーを持つコミットを記録することは間違いであり、コマンドはそのようなコミットを行うことを防ぎます。 このオプションは安全性をバイパスし、主に外部SCMインターフェイススクリプトで使用するためのものです。|
|--allow-empty-message|--allow-emptyと同様に、このコマンドは主に外部SCMインターフェイススクリプトで使用するためのものです。 git-commit-tree のような配管コマンドを使用せずに、空のコミットメッセージでコミットを作成できます。|
|--cleanup=\<mode>|このオプションは、提供されたコミットメッセージをコミットする前にクリーンアップする方法を決定します。 \<mode>は、ストリップ、空白、逐語的、はさみ、またはデフォルトにすることができます。|
|-e<br>--edit|-Fを使用してファイルから、-mを使用してコマンドラインから、および-Cを使用してコミットオブジェクトから取得したメッセージは、通常、変更されていないコミットログメッセージとして使用されます。 このオプションを使用すると、これらのソースから取得したメッセージをさらに編集できます。|
|--no-edit|エディターを起動せずに、選択したコミットメッセージを使用します。 たとえば、git commit --amend --no-editは、コミットメッセージを変更せずにコミットを修正します。|
|--amend|新しいコミットを作成して、現在のブランチの先端を置き換えます。 記録されたツリーは通常どおりに準備され（-iおよび-oオプションと明示的なpathspecの効果を含む）、他のメッセージが指定されていない場合、空のメッセージの代わりに元のコミットからのメッセージが開始点として使用されます コマンドラインから-m、-F、-cなどのオプションを使用します。新しいコミットには、現在のコミットと同じ親と作成者があります（--reset-authorオプションはこれを打ち消すことができます）。|
|--no-post-rewrite|書き換え後のフックをバイパスします。|
|-i<br>--include|これまでにステージングされたコンテンツからコミットを行う前に、コマンドラインで指定されたパスのコンテンツもステージングします。 競合するマージを終了しない限り、これは通常、必要なものではありません。|
|-o<br>--only|他のパス用にステージングされたコンテンツを無視して、コマンドラインで指定されたパスの更新された作業ツリーのコンテンツを取得してコミットします。 これは、コマンドラインでパスが指定されている場合のgit commitのデフォルトの動作モードです。この場合、このオプションは省略できます。 このオプションを--amendと一緒に指定する場合、パスを指定する必要はありません。これを使用すると、すでにステージングされている変更をコミットせずに最後のコミットを修正できます。 --allow-emptyパスと一緒に使用する場合も不要であり、空のコミットが作成されます。|
|--pathspec-from-file=\<file>|Pathspecは、コマンドライン引数の代わりに\<file>で渡されます。 \<file>が正確に-の場合、標準入力が使用されます。 Pathspec要素はLFまたはCR / LFで区切られます。 Pathspec要素は、構成変数core.quotePathで説明されているように引用できます（git-configを参照）。 --pathspec-file-nulおよびglobal--literal-pathspecsも参照してください。|
|--pathspec-file-nul|--pathspec-from-fileでのみ意味があります。 Pathspec要素はNUL文字で区切られ、他のすべての文字は文字通りに解釈されます（改行と引用符を含む）。|
|-u[\<mode>]<br>--untracked-files[=\<mode>]|追跡されていないファイルを表示します。<br><br>modeパラメーターはオプション（デフォルトはall）であり、追跡されていないファイルの処理を指定するために使用されます。 -uを使用しない場合、デフォルトは通常です。つまり、追跡されていないファイルとディレクトリを表示します。※1  |
|-v<br>--verbose|HEADコミットとコミットメッセージテンプレートの下部にコミットされる内容との統一された差分を表示して、ユーザーがコミットの変更内容を思い出させることでコミットを説明できるようにします。 このdiff出力には、行の前に＃が付いていないことに注意してください。 この差分は、コミットメッセージの一部にはなりません。 git-configのcommit.verbose構成変数を参照してください。<br><br>2回指定した場合は、コミットされるものとワークツリーファイルの間の統一された差分、つまり、追跡されたファイルへのステージングされていない変更を追加で表示します。|
|-q<br>--quiet|コミット要約メッセージを抑制します。|
|--dry-run|コミットを作成しないでください。ただし、コミットされるパス、コミットされないままになるローカル変更のあるパス、および追跡されないパスのリストを表示してください。|
|--status|エディターを使用してコミットメッセージを準備する場合は、git-status [1]の出力をコミットメッセージテンプレートに含めます。 デフォルトはオンですが、構成変数commit.statusをオーバーライドするために使用できます。|
|--no-status|エディターを使用してデフォルトのコミットメッセージを準備する場合は、コミットメッセージテンプレートにgit-status の出力を含めないでください。|
|-S[\<keyid>]<br>--gpg-sign[=\<keyid>]<br>--no-gpg-sign|GPG-コミットに署名します。 keyid引数はオプションであり、デフォルトはコミッターIDです。 指定する場合は、スペースなしでオプションに固定する必要があります。 --no-gpg-signは、commit.gpgSign構成変数と以前の--gpg-signの両方を無効にするのに役立ちます。|
|\<pathspec>…​|コマンドラインでpathspecが指定されている場合、インデックスにすでに追加されている変更を記録せずに、pathspecに一致するファイルの内容をコミットします。 これらのファイルの内容は、以前にステージングされたものに加えて、次のコミットのためにもステージングされます。<br><br>詳細については、gitglossaryのpathspecエントリを参照してください。|

※1  
modeパラメーターはオプション（デフォルトはall）であり、追跡されていないファイルの処理を指定するために使用されます。
-uを使用しない場合、デフォルトは通常です。つまり、追跡されていないファイルとディレクトリを表示します。<br>
可能なオプションは次のとおりです。
* no - 追跡されていないファイルを表示しません
* normal - 追跡されていないファイルとディレクトリを表示します
* all - 追跡されていないディレクトリ内の個々のファイルも表示します
